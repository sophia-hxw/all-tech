## 面向对象设计原则

- 单一职责原则(Single Responsibility Principle)
    一个类应该是一组相关性很高的方法和数据的封装

- 开闭原则(Open Closed Principle)
    模块应对拓展开放，而对修改关闭；尽量在不修改源代码的情况下进行拓展

- 里氏替换原则(Liskov Substitution Principle)
    依赖面向对象的继承和多态，即在调用父类的地方换成子类也可以完全运行

- 依赖倒置原则(Dependence Inversion Principle)
    抽象不应该依赖于细节，细节应当依赖于抽象；要针对接口编程，而不是针对实现编程；高层模块不依赖于底层模块，二者都依赖于抽象

- 接口隔离原则(Interface Segregation Principle)
    类不应该依赖它不需要的接口，且依赖的接口尽可能的小，且每一个接口都应该是一种角色

- 最小知识原则(Principle of Least Knowledge)
    一个类应该对自己需要耦合或者调用的类知道的最少，如何实现与调用者和依赖者没关系，调用或依赖者也只需知道它需要的方法，其他可不用管

## 类别

- 创建型模式：单例模式，抽象工厂模式，创建者模式，工厂模式和原型模式
- 结构型模式：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式和代理模式
- 行为型模式：模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式

### 单例模式

一个类只有一个实例，并提供访问它的全局访问点，避免资源过多消耗

加载图片的ImageLoad对象，线程池对象，缓存对象，网络请求对象，数据库对象，文件对象，登录状态对象，日志对象，某些公共数据对象

### Builder模式
将一个复杂对象的构建与它的表现形式分离，使得同样的构建过程可以创建不同的表示形式

### 原型模式
允许通过复制现有的实例来创建新的实例，当创建给定的类较复杂或消耗资源较多时，可用原型模式；

注意深浅拷贝问题

### 工厂方法模式
定义了一个用于创建对象的接口，让子类决定将哪一个类实例化，使一个类的实例化延迟到其子类

### 策略模式
定义一系列的算法，并把每一个算法封装起来，且使他们可以相互替换，使得算法的变化可独立于使用它的客户。

### 状态模式
允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它所属的类

### 命令模式
将请求封装为对象，从而使用不同的请求或对垒来参数化其他对象

### 观察者模式
定义对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新

### 备忘录模式
在不破坏封装性的前提下，存储对象的关键状态，并在改对象之外保存这个状态，这样以后就可将该对象恢复到保存状态

### 迭代器模式
提供一种方法顺序访问一个聚合对象中的各个元素，而且不需暴露该对象的内部表示，适用于遍历一个容器对象，如数组，链表和map等

### 模板方法模式
定义了一个算法的骨架，将一些步骤延迟到子类中，使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤

### 代理模式
为另一个对象提供一个替身，以控制对这个对象的访问

### 组合模式
将对象组合成树形结构以表示“整理/部分”的层次结构，能让客户以一致的方式处理个别对象及对象组合

### 适配器模式
将一个类的结构转换成客户希望的另外一个接口，从而使原本接口不兼容的两个类能够在一起工作

### 外观模式
提供了一个统一的接口，用来访问子系统中的一群接口，它定义了一个高层接口，让子系统更加容易使用

### 桥接模式
将实现和抽象放在两个不同的层次中，从而使它们可以独立改变














